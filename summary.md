# Week 1
## IntegerTypeTest
- 正数。第一位是符号位，正数的符号位都是0.正数用原码表示。最大整数是`0x7fffffff`
- 负数。第一位是符号位，负数的符号位都是1.负数用补码表示。最小整数是`0x80000000`
- Java中简单的加减操作不会关注符号位，最大整数加一会变成最小整数。大数的加减应该调用`Math.addExact()`,当符号位溢出时会抛出异常.
- Java中写16进制数字时可以用下划线分割来增加可读性.如`0x0000_ffff`
- 整数做除法会自动忽略小数位
- 位数转换时会自动忽略高位，例如`0x0234_5678`转换成为short类型时会转为`0x5678`
- 位操作符的使用。`>>`操作符忽略符号位，`>>>`操作符不会忽略符号位
- `++`前置时先自加后赋值；`++`后置时先赋值后自加

## FloatTypeTest
- NaN和任何数比较的结果都是false,NaN和自身的比较结果也是false
- 正（负）无穷于正（负）无穷相等
- 浮点数显式转换为整数时忽略小数位

## CharTypeTest
- Unicode 兼容 ASCII。
- 常见转义字符在Java中的写法

## BooleanOpeartoeTest
- 位运算符号：`| 按位或`，`& 按位与`，`~ 按位取反`
- 逻辑运算符：`|| 逻辑或`，`&& 逻辑与`，`! 非`
- 逻辑运算符若左操作数能确定结果，就不必运算右操作数
- 位操作符左右操作数一定都会运算

## 基本数据类型总结
- 基本数据类型在方法中不初始化不能使用
- 基本数据类型在作为Field时，都会初始化为对应的值，一般是每一位都是0
- 高位类型转为低位类型时需要显式转换，低位类型转化为高位类型时，隐式转换

## ArrayTest
- 数组是一个特殊的类，数组创建出来之后里面的元素都初始化
- 数组在内存中地址是连续的

## StringTest
- String是一个类，不是基本数据类型
- String中的内容是不可变的，String的初始值是null
- String的replace，trim等方法都返回一个新的String
- substring方法可以截取字符串
- split方法按照一个约定的分隔符风格字符串，然后将结果存储在一个数组里面
- 需要对大量字符串进行拼接时，直接用String会导致大量的内存垃圾，这种情况下有限使用StringBUilder
- StringBuilder和StringBuffer都可以拼接字符串，StringBuffer是线程安全的，但性能较差，一般情况下优先使用StringBuilder
- 计算字符串的长度是按照Unicode的个数来计算。有些复杂字符可能占用两个Unicode，也就是32位，这时计算的字符串长度就比实际看到的字符多。
- 看到的字符串长度与codePoint数相等。
- CodePoint的计算：调用Chracher.charCount方法可以计算出当前字符所占码点数，利用这个方法可以计算出码点。
- String的format方法可以用参数替换String的某些特殊字符。

## ObjectTest
- `==`方法用来比较对象在内存中的地址，如果是相同的引用就返回true，否则返回false
- 对象被初始化以后，在调用构造方法之前，所有的field都会初始化，基本类型初始化为响应的值，对象初始化为null。
- Java中的方法都是传值传递。Argument和Parameter不是同一个值。所以当尝试用一个方法区修改一个基本数据类型的值会失败。
- 当Argument时一个对象的引用时，无法通过方法改变其指向的对象，但是可以修改对象里面的值
- 方法签名： 方法签名由方法名和参数类型组成，所以Java支持函数重载，同一个方法名可以有多个不同的实现。
- 构造方法也可以重载，在一个构造方法里面可以显示调用另外一个重载的构造方法。
- Java对象初始化调用顺序： Filed Initializer = Initialization Block > Contructor,Field和代码款执行顺序与代码顺序有关，写在前面的先执行。
-  可变参数： 可变参数实际上是一个数组，当方法签名声明为可变参数时，可以接收多个参数，也可以接收一个数组。

## InheritanceTest
- 当不声明继承关系时，对象默认继承Object类。
- 在派生类的构造方法里不显式调用父类构造方法是，默认调用父类无参构造方法。
- 调用父类构造方法必须方法派生类构造方法的第一行。
- 在类中显式调用自身其他构造方法时，必须放在第一行。
- 派生类可以重写父类方法，把子类对象赋值给父类引用时，父类引用可以调用子类方法。
- 派生类可以调用父类方法
- 数组是个特殊的类，父类的数组不是派生类的数组的父类。
- `instanceof`只用来判断是否可以强转，如果左操作数可以强转为右操作数的对象，则会返回true。
- Perfect equals:

	> 1. 自反性：一个对象与自己比较总是返回true
	> 2. 对称性：对象A与对象B比较返回true，则对象B与对象A比较也返回true
	> 3. 传递性： 对象A与对象B比较返回true，对象B与对象C比较返回true，则对象A与对象C比较一定返回true
	> 4. 一致性： 对象A与对象B在任意时刻比较的返回值都相等，前世是对象A和对象B都没有被修改
	> 5. 任何对象与null比较都返回false.

## ReflectionTest
- Class类：描述类的类。保存了类的信息并提供了一系列的API来获取类的信息。
- 通过`object.getClass()`或`者Object.class`可以获取类的描述信息
- `Class.getName()`可以获取完整的类名。
- `Class.forName()`可以在运行时加载一个类，加载完毕后调用newInstance方法可以创建对象
- `Class.getMethods()`可以获取一个类所有的方法，包括继承来的方法
- `Class.getDeclaredMethods()`可以获取一个类多有声明的方法，不包括继承的方法
- 通过`Method.invoke()`方法可以在运行时调用一个方法，通过方法名可参数类型可以确定唯一一个方法。
- 注解： 注解本身是一个标记，不能做任何事情。可以通过元注解`@Target`声明注解支持的类型，`@Retention`声明注解的生命周期。
- 父类的数组的类不是子类数组的父类

## InterfaceTest
- Java8开始，接口中可以写默认实现，需要声明default关键字。
- 当实现类实现了接口后，使用接口引用调用该方法时，应该调用实现类的方法。
- 实现类中重写方法后应该调用实现类中的方法，如果没有实现，则调用接口中的默认实现。
- Java中继承只能单继承，但是可以实现多个接口，当继承的两个接口中存在两个方法签名一样的方法且都有默认实现时，应该显式重写该方法。

## LambdaTest
- Java8中，只有一个方法的接口叫函数式接口。
- Java8之前可以用匿名类实现一个接口，Java8之后，如果该接口是函数式接口，可以用lambda表达式来实现
- Java8中的lambda表达式实际上是一个语法糖。是实现匿名类的一种简单写法。lambda表达式与接口中声明的方法必须保持方法签名一致同时保持返回值类型一致。
- 在Lambda表达式中使用的外部变量必须声明为final或者实际上是final
- 方法引用，如果类的实例方法或者静态方法的方法签名和返回值与函数式接口中生声明的一样，则可以使用方法引用替代lambda表达式例如`(n) -> System.out.println(n)`可以用`System.out::println`代替。
- lambda表达式中引用的的如果是对象引用，那么就可以修改对象中的内容。但是不可以改变这个引用
- 返回一个lambda表达式可以扩大值域（只是表现形式，实际上当函数弹栈之后，函数中所用的变量也会弹栈）
- 常用函数式接口： Comsumer(接收参数，但是不返回值)；Supplier(不接收参数，但返回值)，Function(接收一个参数且返回值)，BiFunction(接收两个参数，且返回值)。Java8中提供了常用函数式接口，一般不需要自己重新写接口。